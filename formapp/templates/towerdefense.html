{% extends 'header.html' %}
<!-- ^^ This means add this file to the end of the contents of header.html -->
<!-- This is where the title, top buttons, and stylesheet is located -->

<!-- Change title here -->
{% block title %}Blewnz{% endblock %}

<!-- Extra style declarations here -->
{% block style %}
<style>
  body {
    background: var(--bg-darker);
    user-select: none;
  }

  #container {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    aspect-ratio: 16 / 9;
  }

  @media (max-aspect-ratio: 16/9) {
    #container {
      width: 100%;
      font-size: calc(5vw / 6);
    }
  }

  @media (min-aspect-ratio: 16/9) {
    #container {
      height: 100%;
      font-size: calc(40vh / 27);
    }
  }

  #game {
    position: absolute;
    width: 100%;
    background: linear-gradient(to bottom right, #030, #300, #003);
    background-size: 100%;
    outline: 1px solid var(--dark-gray);
  }

  #grid {
    position: absolute;
    top: 0;
    width: 100%;
    aspect-ratio: 32 / 15;
    border-collapse: collapse;
  }

  table, td {
    border: none;
  }

  td {
    width: calc(100% / 32);
  }

  .visibleLines td {
    border: 1px solid #555;
  }

  td.droppable {
    background: #aaa5;
  }

  td.undroppable {
    background: #a555;
  }

  td.tower {
    cursor: pointer;
  }

  .menu {
    position: absolute;
    min-width: 15%;
    max-width: 20%;
    padding: 0.5%;
    box-sizing: border-box;
    background: var(--light-gray);
    color: var(--bg-dark);
    text-align: center;
  }

  .splitButton {
    color: var(--color-green);
    border: 1px solid;
    border-radius: 4px;
    font-size: 80%;
    font-weight: 500;
  }

  .splitButton:not(.unselectable) {
    cursor: pointer;
  }

  .buttonLeft {
    width: fit-content;
    padding: 0 1.5%;
    border-radius: 4px 0 0 4px;
    background: white;
  }

  .buttonRight {
    width: fit-content;
    padding: 0 1.5%;
    border-radius: 0 4px 4px 0;
    background: var(--color-green);
    color: white;
  }

  .splitButton:not(.unselectable):hover {
    filter: brightness(90%);
  }

  .sellButton {
    color: var(--color-red);
  }

  .sellButton .buttonRight {
    background: var(--color-red);
  }

  h1 {
    margin: 0 0 4% 0;
    font-size: 150%;
    font-weight: normal;
  }

  h2 {
    margin: 3% 0 0 0;
    font-size: 125%;
    font-weight: normal;
  }

  #towers {
    position: absolute;
    bottom: 0;
    width: 100%;
    aspect-ratio: 32 / 3;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 3%;
    background: #0005;
    border-top: 1.5px solid var(--light-gray);
    cursor: default;
  }

  #towers img {
    height: calc(100% / 3);
  }

  #towers img:not(.unselectable):hover {
    cursor: grab;
    filter: drop-shadow(0 0 6px white);
  }

  #towers img:not(.unselectable):active {
    cursor: grabbing;
  }

  #towers img.unselectable {
    opacity: 25%;
  }

  #alert {
    position: absolute;
    right: 15px;
    top: 15px;
    width: 60px;
    opacity: 75%;
    cursor: pointer;
  }

  #alert:hover {
    opacity: 100%;
  }
</style>
{% endblock %}

<!-- Main content here -->
{% block main %}
  <div id="container">
    <canvas id="game" width="1920" height="1080"></canvas>
    <!-- Remove this alert if Google Chrome fixes the bug -->
    <img src="{{ url_for('static', filename='img/towerdefense/alert.png') }}" id="alert" onclick="alert('If a popup appears while you are dragging a tower, you may become unable to interact with the game.\nThis is an issue with the browser, not the game.\nYou can end this glitch by dragging something onto this page from another tab.');">
    <table id="grid" class="hidden"></table>
    <div id="towers" class="hidden">
      <div id="towerDesc"></div>
    </div>
  </div>
{% endblock %}

<!-- Extra javascript here -->
{% block script %}
  <script>
    let towerTypes = {
      basic: {
        name: "Basic Tower",
        description: "",
        range: 2.5,
        speed: 1,
        strength: 1,
        price: 25,
        extra1: {
          description: "Projectiles can hit up to three nearby enemies.",
          price: 15,
          add: function() {
            this.bounce = true;
          }
        },
        extra2: {
          description: "",
          add: function() {}
        },
        ability: {
          description: "Attacks 5× as fast for 10 seconds.",
          use: function() {
            this.speedBoost = 250;
            ////make speedBoost work
          }
        }
      },
      slowing: {
        name: "Slowing Tower",
        description: "Weak attacks, but hits slow down enemies for 10 seconds.",
        range: 3.25,
        speed: 0.75,
        strength: 0.75,
        slowing: true,
        price: 20,
        extra1: {
          description: "Slowing affects enemies permanently.",
          add: function() {
            this.permSlow = true;
          }
        },
        extra2: {
          description: "Enemies lose all abilities while they are slowed down.",
          add: function() {
            this.abilityBlocking = true;
          }
        },
        ability: {
          description: "Freezes every onscreen enemy for 3 seconds. Frozen enemies take twice as much damage.",
          use: function() {
            enemies.forEach(enemy => enemy.frozen = 75);
          }
        }
      },
      longRange: {
        name: "Long Range Tower",
        description: "Infinite range and strong attacks, but fires slowly. Targets the strongest enemy onscreen.",
        range: Infinity,
        speed: 0.46,
        strength: 4,
        price: 60,
        extra1: {
          description: "Can hit blinking enemies while they are hidden.",
          add: function() {
            this.superVision = true;
          }
        },
        extra2: {
          description: "Enemies hit by this tower lose all abilities permanently.",
          add: function() {
            this.removeAbilities = true;
          }
        },
        ability: {
          description: "Does 150 damage the strongest enemy on the screen.",
          use: function() {
            let strongest = enemies.sort((a, b) => b.health - a.health)[0];
            strongest.hit(Infinity, this);
          }
        }
      },
      cannon: {
        name: "Cannon Tower",
        description: "Every hit creates an explosion that damages nearby enemies.",
        range: 3.25,
        speed: 0.72,
        strength: 2,
        price: 75,
        explosionSize: 100,
        extra1: {
          description: "Explosions are increased in size.",
          add: function() {
            this.explosionSize = 150;
          }
        },
        extra2: {
          description: "Explosions do as much damage as direct hits.",
          add: function() {
            this.powerfulExplosions = true;
          }
        },
        ability: {
          description: "Creates a giant explosion that does significant damage.",
          use: function(tower) {
            let inExplosion = enemies.filter(enemy => Math.sqrt((tower.x - enemy.x) ** 2 + (tower.y - enemy.y) ** 2) < 400);
            inExplosion.forEach(enemy => enemy.hit(25, this, true));
            ctx.strokeStyle = "transparent";
            ctx.fillStyle = "#ff8f4055";
            ctx.drawCircle(tower.x, tower.y, 400);
          }
        }
      },
      money: {
        name: "Money Tower",
        description: "Gets 5× as much money from hitting enemies.",
        range: 3.5,
        speed: 0.85,
        strength: 1.5,
        extraMoney: true,
        price: 100,
        extra1: {
          description: "Adds an extra $20 every 10 seconds.",
          add: function() {
            player.bonusMoney += 20;
          }
        },
        extra2: {
          description: "Adds an extra life every 15 seconds.",
          add: function() {
            player.bonusLives += 1;
          }
        },
        ability: {
          description: "Adds $50 to your total.",
          use: function() {
            player.money += 50;
          }
        }
      },
      air: {
        name: "Air Tower",
        large: true,
        description: "This tower can move anywhere on the screen. Double-click to make it follow your cursor, and double-click again to make it stay in place. You can only own one.",
        range: 2.5,
        speed: 3,
        strength: 1,
        movable: true,
        price: 100,
        extra1: {
          description: "Every fifth hit creates a small explosion.",
          add: function() {}
        },
        extra2: {
          description: "Whatever tower is closest to the plane will get a range boost.",
          add: function() {}
        },
        ability: {
          description: "",
          use: function() {}
        }
      },
      ultimate: {
        name: "Ultimate Tower",
        large: true,
        description: "",
        range: 4.5,
        speed: 9.3,
        strength: 2,
        price: 250,
        extra1: {
          description: "Does extra damage to boss enemies.",
          add: function() {
            this.bossBonus = true;
          }
        },
        extra2: {
          description: "Attack power is slightly increased for each enemy on the screen.",
          add: function() {}
        },
        ability: {
          description: "All towers get double range, speed, and strength for 10 seconds.",
          use: function() {}
        }
      }
    };
    for (let type in towerTypes) {
      towerTypes[type].upgrades = {
        range: 0,
        speed: 0,
        strength: 0
      };

      towerTypes[type].img = new Image();
      towerTypes[type].img.src = `../static/img/towerdefense/${type}.png`;
      towerTypes[type].activeImg = new Image();
      towerTypes[type].activeImg.src = `../static/img/towerdefense/${type}-active.png`;
    }

    let enemyTypes = {
      green: {
        speed: 1,
        health: 1
      },
      yellow: {
        speed: 1.5,
        health: 2
      },
      orange: {
        speed: 2,
        health: 3
      },
      red: {
        speed: 2.5,
        health: 4,
        color: "red"
      },
      purple: {
        speed: 4,
        health: 1
      },
      brown: {
        speed: 1,
        health: 10
      },
      boss: {
        speed: 0.5,
        health: 100,
        boss: true
      },
      superBoss: {
        speed: 0.25,
        health: 500,
        boss: true
      },
    };
    for (let type in enemyTypes) {
      enemyTypes[type].img = new Image();
      enemyTypes[type].img.src = `../static/img/towerdefense/${type}.png`;
      if (enemyTypes[type].boss) {
        enemyTypes[type].imgRotated = new Image();
        enemyTypes[type].imgRotated.src = `../static/img/towerdefense/${type}-r.png`;
      }
    }

    class Tower {
      constructor(type, row, col) {
        for (let property in type) this[property] = type[property];
        this.value = type.price;
        this.x = col * 60 + 30;
        this.y = row * 60 + 30;
        this.i = towers.length;
        this.cooldown = 0;
        this.showMenu = function() {
          if (!paused) {
            this.menuOpen = true;

            let menu = document.createElement("div");
            menu.classList.add("menu");
            menu.style.left = this.x / 1920 * 100 + "%";
            menu.style.top = "10%";
            menu.style.transform = "translateX(-50%)";
            menu.innerHTML = `
              <h1>${type.name}</h1>


              <h2><span id="${this.i}-sell" class="splitButton sellButton">
                <span class="buttonLeft">Sell</span><span class="buttonRight">+$${this.sellValue}</span>
              </span></h2>

              <h2 id="${this.i}-range">
                Range: ${this.range}
                <span class="splitButton ${(player.money <= this.upgradePrice("range")) ? "unselectable" : ""}">
                  <span class="buttonLeft">→&nbsp;${this.range + 1}</span><span class="buttonRight">${this.upgradePrice("range") ? "$" + this.upgradePrice("range") : "Max"}</span>
                </span>
              </h2>

              <h2 id="${this.i}-speed">
                Speed: ${this.speed}
                <span class="splitButton ${(player.money <= this.upgradePrice("speed")) ? "unselectable" : ""}">
                  <span class="buttonLeft">→&nbsp;${this.speed * 2}</span><span class="buttonRight">${this.upgradePrice("speed") ? "$" + this.upgradePrice("speed") : "Max"}</span>
                </span>
              </h2>

              <h2 id="${this.i}-strength">
                Strength: ${this.strength}
                <span class="splitButton ${(player.money <= this.upgradePrice("strength")) ? "unselectable" : ""}">
                  <span class="buttonLeft">→&nbsp;${this.strength * 2}</span><span class="buttonRight">${this.upgradePrice("strength") ? "$" + this.upgradePrice("strength") : "Max"}</span>
                </span>
              </h2>

              <h2>
                Extra ${this.extra1.bought ? "2" : "1"}
                <span id="${this.i}-extra" class="splitButton">
                  <span class="buttonLeft">Add</span><span class="buttonRight">$${this.nextExtra.price}</span>
                </span>
              </h2>
              ${this.nextExtra?.description || this.extra2.description}

              <h2>
                Special ability
                <span id="${this.i}-ability" class="splitButton">
                  <span class="buttonLeft">Unlock</span><span class="buttonRight">$${this.ability.price}</span>
                </span>
              </h2>
              ${type.ability.description}
            `;

            document.getElementById("container").appendChild(menu);
            document.getElementById(this.i + "-sell").onclick = () => {
              towers[this.i] = null;
              player.money += this.sellValue;
              let row = Math.floor(this.y / 60);
              let col = Math.floor(this.x / 60);
              grid[row][col] = null; //Reset the grid square
              menu.remove();
              this.menuOpen = false;
            };
            document.getElementById(this.i + "-range").onclick = () => {
              if (this.upgrades.range < 2 && player.money >= this.upgradePrice("range")) {
                player.money -= this.upgradePrice("range");
                this.value += this.upgradePrice("range");
                this.upgrades.range++;
                this.range += 1;
                //Update the menu
                menu.remove();
                this.showMenu();
              }
            };
            document.getElementById(this.i + "-speed").onclick = () => {
              if (this.upgrades.speed < 2 && player.money >= this.upgradePrice("speed")) {
                player.money -= this.upgradePrice("speed");
                this.value += this.upgradePrice("speed");
                this.upgrades.speed++;
                this.speed *= 2;
                menu.remove();
                this.showMenu();
              }
            };
            document.getElementById(this.i + "-strength").onclick = () => {
              if (this.upgrades.strength < 2 && player.money >= this.upgradePrice("strength")) {
                player.money -= this.upgradePrice("strength");
                this.value += this.upgradePrice("strength");
                this.upgrades.strength++;
                this.strength *= 2;
                menu.remove();
                this.showMenu();
              }
            };
            document.getElementById(this.i + "-extra").onclick = () => {
              if (player.money >= this.nextExtra.price) {
                player.money -= this.nextExtra.price;
                this.value += this.nextExtra.price;
                this.nextExtra.bought = true;
                this.nextExtra.add.bind(this)();
                menu.remove();
                this.showMenu();
              }
            };
            document.getElementById(this.i + "-ability").onclick = () => {
                if (player.money >= this.ability.price) {
                player.money -= this.ability.price;
                this.value += this.ability.price;
                this.ability.bought = true;
                menu.remove();
                this.showMenu();
              }
            };

            document.getElementById("grid").onmousedown = () => {
              menu.remove();
              this.menuOpen = false;
            };
          }
        }
        this.upgradePrice = (stat) => (this.upgrades[stat] == 2) ? null : this.price * ((this.upgrades[stat] == 1) ? 5 : 2);
      }

      get sellValue() {
        return Math.round(this.value * 0.75);
      }

      get nextExtra() {
        return this.extra2.bought ? null : (this.extra1.bought ? this.extra2 : this.extra1);
      }
    }

    class Enemy {
      constructor(string) {
        if (string[0] == "g") this.type = enemyTypes.green;
        if (string[0] == "y") this.type = enemyTypes.yellow;
        if (string[0] == "o") this.type = enemyTypes.orange;
        if (string[0] == "r") this.type = enemyTypes.red;
        if (string[0] == "p") this.type = enemyTypes.purple;
        if (string[0] == "b") this.type = enemyTypes.brown;
        if (string[0] == "x") this.type = enemyTypes.boss;
        if (string[0] == "z") this.type = enemyTypes.superBoss;
        this.speed = this.type.speed;
        this.health = this.type.health;
        this.abilities = [];
        if (string[1] == "h") this.abilities.push("healing");
        if (string[1] == "u") this.abilities.push("speed up");
        if (string[1] == "s") this.abilities.push("split");
        if (string[1] == "k") this.abilities.push("blink");
        if (string[1] == "d") this.abilities.push("shield");
        this.id = Math.random(); //Give the enemy a random ID so that no two objects are identical
        this.distance = 0;
        this.visible = !this.abilities.includes("blink");
        this.slowed = 0;
        this.hit = function(damage, tower, explosion) {
          if (!this.abilities.includes("shield") || explosion || tower.name == "Long Range Tower") this.health -= damage;
          if (this.health <= 0) {
            player.money += (this.type.boss ? 10 : 1) * (tower?.extraMoney ? 5 : 1);
            enemies.splice(enemies.indexOf(this), 1);
          } else {
            if (this.abilities.includes("speed up")) this.speed = this.type.speed + this.type.speed * (1 - (this.health / this.type.health)) * 3;
            if (tower?.removeAbilities) this.abilities = [];
          }
        }
      }
    }

    let pause = [10, null];
    let waves = [
      [[4, "g", pause], "g"],
      [[7, "g", "g", pause], ["alert", "All enemy types have different HP and speed stats."], "y", pause, "y"],
      [[5, "g"], [3, "y"]],
      [[20, "g"]],
      [[2, "y"], [5, [3, "g"], pause], [3, "y"]],
      [[10, "y"], [4, "o", pause], "o"],
      [[6, "g", "y", "o", pause], "g", "y", "o"],
      [[9, "y"], [7, "o"]],
      [[50, "g"]],
      [["alert", "New enemy ability: HEALING\nEnemies with this ability gradually regain health, so you need to destroy them quickly."], [9, "oh", pause], "oh"],
      [[7, [6, "y", pause]], [6, "y"]],
      [[20, "oh"]],
      [[15, "o", "y"]],
      [[32, "g"], pause, [16, "y"], pause, [8, "o"], pause, [4, "r"]],
      [[6, "r"], ["alert", "New enemy ability: SPEED UP\nEnemies with this ability move faster as they lose health. They also can't be slowed by Slowing Towers."], [10, "ou"]],
      [[5, "g", [3, "r"], "g", pause], "g", [3, "r"], "g"],
      [[8, "ou", "ru", pause], "ou", "ru"],
      [[2, [12, "r"], pause], [12, "r"]],
      [[100, "y"]],
      [[2, "b", pause], "b"],
      [["alert", "New enemy ability: SPLIT\nEnemies with this ability split into two or more weaker enemies when they run out of health, making them much harder to destroy."], "rs"],
      [[7, "y", "o", "r", pause], [12, "rh"]],
      [[4, "os"], pause, [25, "o"], "bs"],
      [[5, "p"]],
      [[3, "pu", "bh", pause], [8, "rs", pause], "rs"],
      [["alert", "New enemy ability: BLINK\nEnemies with this ability switch between two states: visible and hidden. Without upgrades, towers can only hit them while they're visible."], [29, "yk", pause], "yk"],
      [[250, "g"]],
      [["alert", "Boss enemies have 100 HP."], "x"],
      ["pk"],
      [[5, "bs"]],
      [[2, [35, "r"], [5, "p"]]],
      [[14, "bu"], [26, "rh"]],
      [["alert", "New enemy ability: SHIELD\nEnemies with this ability can only be damaged by explosions and hits from Long-Range Towers."], "gd"],
      [[30, "o"], pause, "x", pause, "x"],
      [[3, "bs"], [3, "ps"]],
      [[20, "rk"], pause, [5, "bk"]],
      [[3, "bd", pause], "bd"],
      ["xs"],
      [[10, "ok"], [8, "rh"], [19, "p"], [4, "rs"]],
      [[125, "yh"], "xu", [33, "b"]],
      [[4, "x"], [45, "r"], "xk"],
      [[7, "os"], pause, [13, "pk"] [64, "g"]],
      ["x", [18, "rd"], pause, "x"],
      [[85, "b", "p"]],
      [["alert", "Superboss enemies have 500 HP."], "z"],
      [[10, "x"], pause, [30, "bh"], [20, "r"]],
      [[3, "z", pause], [17, "ps"], [43, "ok"], [5, "x"]],
      [[15, "pk"], "xs", [3, "x", "z"], [300, "o"], "pd"],
      [[50, "ru"], [125, "bk"], pause, [67, "bh"], [999, "yk"], "z"],
      [[10, "g"], pause, [20, "y"], pause, [30, "o"], pause, [40, "r"], pause, [100, "b"], pause, [100, "p"], pause, [15, "x"], pause, [5, "z"]]
    ];
    waves.forEach(wave => wave.unshift([8, pause])); //Add a break at the start of each wave

    let grid = Array(15).fill().map(() => Array(32).fill(null)); //Array containing 15 arrays (rows), each containing 32 items (columns). Makes a deep copy of each array.
    grid[0].fill("button", 0, 2); //Two buttons in to top left
    grid[0].fill("info", 26, 32); //Area for game info in the top right

    let dragOver;

    let buttons = {
      fullscreen: new Image(),
      exitFullscreen: new Image(),
      pause: new Image(),
      play: new Image(),
      fastForward: new Image()
    };
    for (let button in buttons) buttons[button].src = `../static/img/towerdefense/${button}.png`;

    let abilitySymbols = {
      healing: new Image(),
      shield: new Image()
    };
    for (let symbol in abilitySymbols) abilitySymbols[symbol].src = `../static/img/towerdefense/${symbol}.png`;

    let canvas = document.getElementById("game");
    let ctx = canvas.getContext("2d");

    ctx.drawCircle = function(x, y, r) {
      this.beginPath();
      this.arc(x, y, r, 0, 2 * Math.PI);
      this.stroke();
      this.fill();
    }

    ctx.drawPath = function(instructions) {
      this.lineWidth = 1.5;
      this.strokeStyle = "#80ffff";
      this.beginPath();
      let xPos = instructions.start[0] * 60;
      let yPos = instructions.start[1] * 60;
      let col = instructions.start[0] - 0.5;
      let row = instructions.start[1] - 0.5;
      instructions.lines.forEach(line => {
        this.moveTo(xPos, yPos);
        for (let i = 0; i < line[1]; i++) {
          switch (line[0]) {
            case "right":
              xPos += 60;
              col++;
              break;
            case "left":
              xPos -= 60;
              col--;
              break;
            case "down":
              yPos += 60;
              row++;
              break;
            case "up":
              yPos -= 60;
              row--;
          }
          this.lineTo(xPos, yPos);
          if (grid[row][col] === null) grid[row][col] = "track"; //Change the value of every square the path goes through
        }
      });
      this.stroke();
    }

    function update() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); //Clear the canvas
      ctx.drawPath(map);

      //ctx.drawImage(document.fullscreenElement ? buttons.exitFullscreen : buttons.fullscreen, 15, 15, 30, 30);
      ctx.drawImage(buttons.pause, 15, 15, 30, 30);
      ctx.drawImage(fastForward ? buttons.play : buttons.fastForward, 75, 15, 30, 30);
      //document.getElementById("r0c0").onclick = () => document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen();
      document.getElementById("r0c0").onclick = () => {
        paused ? animate = setInterval(update, fastForward ? 10 : 40) : clearInterval(animate);
        paused = !paused;
        paused ? document.getElementById("towers").classList.add("hidden") : document.getElementById("towers").classList.remove("hidden");
        ////disable popups
        ctx.clearRect(0, 0, 120, 60);
        ctx.drawImage(buttons.play, 15, 15, 30, 30);
      };
      document.getElementById("r0c1").onclick = () => {
        fastForward = !fastForward;
        clearInterval(animate);
        animate = setInterval(update, fastForward ? 10 : 40); //If fast forward is turned on, play at 4x the normal speed
      };

      if (!(frame % 25) && frame) seconds++; //Do this every 25 frames

      ////dragOver
      if (dragOver) {
        ctx.strokeStyle = "white";
        ctx.fillStyle = "#aaa5";
        ctx.drawCircle(dragOver[1] * 60 + 30, dragOver[2] * 60 + 30, dragOver[0].range * 60);
      }

      //Spawn enemies
      if (!(frame % 4)) {
        let next = waves[currentWave][currentEnemy];
        while (Array.isArray(next)) {
          if (next[0] == "alert") {
            alert(next[1]);
            waves[currentWave].splice(currentEnemy, 1); //Remove the array
          } else {
            let repeat = next[0]; //The array's first item is the number of times to repeat
            let items = next.slice(1); //Everything that follows is repeated
            let repeated = Array(repeat).fill(items).flat(); //Make an array containing the items array repeated, then flatten it
            waves[currentWave].splice(currentEnemy, 1, ...repeated); //Add each item in repeated to the wave and remove the array
          }
          next = waves[currentWave][currentEnemy];
        }
        //Display next enemy
        if (next) {
          let newEnemy = new Enemy(next);
          enemies.push(newEnemy);
        }

        if (waves[currentWave][currentEnemy + 1] !== undefined) { //There are enemies left in the wave
          currentEnemy++;
        } else {
          if (!waves[currentWave + 1]) { //There are no waves left
            //Once all enemies are defeated, end the game
            if (enemies.length) {
              waves[currentWave + 1] = [null];
            } else {
              alert("Congratulations! You have passed every wave.");
              endGame();
            }
          }
          currentWave++;
          currentEnemy = 0;
        }
      }

      towers.forEach(tower => {
        if (tower) {
          ctx.drawImage(tower.img, tower.x - 30, tower.y - 30);

          if (tower.menuOpen) {
            ctx.strokeStyle = "white";
            ctx.fillStyle = "#aaa5";
            ctx.drawCircle(tower.x, tower.y, tower.range * 60);
          }

          if (tower.ability.cooldown) tower.ability.cooldown--;

          if (tower.cooldown > 1) {
            tower.cooldown--;
          } else {
            let inRange = enemies.filter(enemy => Math.sqrt((tower.x - enemy.x) ** 2 + (tower.y - enemy.y) ** 2) < tower.range * 60); //Use the Pythagorean Theorem to determine if each enemy is inside the tower's range
            if (!tower.seeInvisible) inRange = inRange.filter(enemy => enemy.visible);
            if (inRange.length) {
              let furthest = inRange.sort((a, b) => b.distance - a.distance)[0]; //Sort inRange from highest to lowest distance and get the first item
              let strongest = inRange.sort((a, b) => b.health - a.health)[0]; //Sort inRange from highest to lowest health and get the first item
              let target = (tower.range == Infinity) ? strongest : furthest;
              let damage = tower.strength * ((tower.bossBonus && target.boss) ? 1.5 : 1);
              target.hit(damage, tower);
              if (tower.slowing && !target.abilities.includes("speed up")) target.slowed = tower.permSlow ? Infinity : 250;
              if (tower.abilityBlocking && !target.abilities.includes("speed up")) {
                target.noAbilities = tower.permSlow ? Infinity : 250;
                ////make noAbilities work
              }
              if (tower.bounce) {
                let closest = enemies.sort((a, b) => ((target.x - a.x) ** 2 + (target.y - a.y) ** 2) - ((target.x - b.x) ** 2 + (target.y - b.y) ** 2))[0];
                ////bounce
              }
              if (tower.explosionSize) {
                //Create an explosion centered around the target enemy
                let inExplosion = enemies.filter(enemy => Math.sqrt((target.x - enemy.x) ** 2 + (target.y - enemy.y) ** 2) < tower.explosionSize);
                let explosionDamage = tower.powerfulExplosions ? tower.strength : 1;
                inExplosion.forEach(enemy => enemy.hit(explosionDamage, tower, true)); //Do damage to every enemy inside the explosion
                //Draw the explosion as an orange circle
                ctx.strokeStyle = "transparent";
                ctx.fillStyle = "#ff8f4055";
                ctx.drawCircle(target.x, target.y, tower.explosionSize);
              }
              ctx.drawImage(tower.activeImg, tower.x - 30, tower.y - 30);
              tower.cooldown += 25 / tower.speed;
            }
          }
        }
      });

      enemies.forEach((enemy, i) => {
        if (enemy.slowed) enemy.slowed--;

        if (enemy.abilities.includes("healing") && enemy.health < enemy.type.health) {
          enemy.health += 1 / 75;
          if (enemy.health > enemy.type.health) enemy.health = enemy.type.health;
        }

        if (!(frame % 25) && enemy.abilities.includes("blink")) enemy.visible = !enemy.visible;

        //If enemy is offscreen, subtract a life and remove it from the array
        //Otherwise, draw it in its new position
        if (enemy.x - 20 > 1920) {
          player.lives -= enemy.type.health;
          enemies.splice(i, 1);
        } else {
          ctx.strokeStyle = enemy.type.color;
          enemy.distance += enemy.speed * (enemy.slowed ? 2 : 4);
          enemy.x = map.start[0] * 60;
          enemy.y = map.start[1] * 60;
          let img;
          for (let i = 0; i < Math.round(enemy.distance); i++) {
            if (mapArr[i] == "right") enemy.x += 1;
            if (mapArr[i] == "left") enemy.x -= 1;
            if (mapArr[i] == "down") enemy.y += 1;
            if (mapArr[i] == "up") enemy.y -= 1;
            img = enemy.type.boss && (mapArr[i] == "right" || mapArr[i] == "left") ? img = enemy.type.imgRotated : enemy.type.img; //If the enemy is a boss and moving horizontally, rotate it
          }
          if (!enemy.visible) ctx.globalAlpha = 0.25; //If the enemy is hidden, amke it semitransparent
          ctx.drawImage(img, enemy.x - 40, enemy.y - 40);
          ctx.globalAlpha = 1;
          if (enemy.abilities.includes("healing")) ctx.drawImage(abilitySymbols.healing, enemy.x - 40, enemy.y - 40);
          if (enemy.abilities.includes("shield")) ctx.drawImage(abilitySymbols.shield, enemy.x - 40, enemy.y - 40);
        }
      });

      for (let tower in towerTypes) {
        let towerEl = document.getElementById(tower);

        if (player.money >= towerTypes[tower].price) {
          towerEl.classList.remove("unselectable");
          towerEl.draggable = true;
          //Do this when the tower is picked up
          towerEl.ondragstart = () => {
            towerTypes[tower].dragging = true;
            document.getElementById("grid").classList.add("visibleLines"); //Show the grid's lines
            grid.forEach((row, i) => row.forEach((square, j) => {
              let squareEl = document.getElementById("r" + i + "c" + j);
              if (square) { //If the square is not null
                squareEl.ondragover = () => squareEl.classList.add("undroppable");
                squareEl.ondragleave = () => squareEl.classList.remove("undroppable");
                squareEl.ondrop = () => squareEl.classList.remove("undroppable");
              } else {
                squareEl.ondragover = () => {
                  event.preventDefault();
                  squareEl.classList.add("droppable");
                  dragOver = [towerTypes[tower], j, i];
                };
                squareEl.ondragleave = () => {
                  squareEl.classList.remove("droppable");
                  dragOver = null;
                };
                squareEl.ondrop = () => {
                  squareEl.classList.remove("droppable");
                  dragOver = null;
                  document.getElementById("grid").classList.remove("visibleLines");
                  if (player.money >= towerTypes[tower].price) { //Check that the player can afford the tower again to prevent cheating
                    //Place the tower
                    player.money -= towerTypes[tower].price;
                    let newTower = new Tower(towerTypes[tower], i, j);
                    towers.push(newTower);
                    grid[i][j] = newTower;
                    let squareEl = document.getElementById("r" + i + "c" + j);
                    squareEl.classList.add("tower");
                    squareEl.onclick = () => newTower.showMenu();
                  }
                };
              }
            }));
          };
          towerEl.ondragend = () => {
            delete towerTypes[tower].dragging;
            document.getElementById("grid").classList.remove("visibleLines");
          };
        } else {
          towerEl.classList.add("unselectable");
          towerEl.draggable = false;
        }
      }

      if (!(frame % 250)) player.money += player.bonusMoney;

      if (!(frame % 375)) player.lives += player.bonusLives;

      //Update text in top-right
      ctx.font = "30px monospace";
      ctx.textAlign = "left";
      if (player.lives > 0) {
        //Display time, money, and lives in the top-right corner
        ctx.fillStyle = "#ddd";
        ctx.fillText(`${Math.floor(seconds / 60).toString().padStart(2, "0")}:${(seconds % 60).toString().padStart(2, "0")}`, 1580, 40); //Show minutes and seconds since the game started
        ctx.fillStyle = "#80ff80";
        ctx.fillText("$" + player.money.toString().padStart(4, "0"), 1700, 40);
        ctx.fillStyle = "#ff6860";
        ctx.fillText("❤︎" + player.lives.toString().padStart(3, "0"), 1820, 40);
      } else {
        endGame();
      }

      frame++;
    }

    let player = {
      money: 50,
      lives: 100,
      bonusMoney: 0,
      bonusLives: 0
    };
    let enemies = [];
    let towers = [];
    let frame = 0;
    let currentWave = 0;
    let currentEnemy = 0;
    let seconds = 0;
    let paused = false;
    let fastForward = false;
    let animate;

    let map = {
      start: [6.5, -0.5],
      lines: [
        ["down", 13],
        ["left", 3],
        ["up", 3],
        ["right", 7],
        ["down", 2],
        ["right", 2],
        ["up", 6],
        ["left", 3],
        ["up", 3],
        ["right", 7],
        ["down", 8],
        ["right", 6],
        ["down", 3],
        ["left", 3],
        ["up", 8],
        ["right", 9],
        ["down", 4],
        ["left", 4],
        ["down", 2],
        ["right", 8],
      ]
    };

    //Make an array with one item for each pixel of the path
    let mapArr = [];
    map.lines.forEach(line => {
      for (let i = 0; i < line[1] * 60; i++) mapArr.push(line[0]);
    });

    ctx.fillStyle = "white";
    ctx.font = "128px Segoe UI";
    ctx.textAlign = "center";
    ctx.fillText("Tower Defense", 960, 300);
    ctx.font = "48px Segoe UI";
    ctx.fillText("Click to start the game", 960, 600);
    ctx.font = "32px Segoe UI";
    ctx.fillText("Created by Oley Birkeland", 960, 1000);

    document.getElementById("game").onclick = function() {
      document.getElementById("alert").classList.add("hidden");

      //Start the game
      animate = setInterval(update, 40);

      //Create the grid
      document.getElementById("grid").classList.remove("hidden")
      let gridHTML = "";
      grid.forEach((row, i) => {
        gridHTML += "<tr>"; //For every array in grid, add a row to the table
        row.forEach((square, j) => gridHTML += `<td id="r${i}c${j}"></td>`); //For every item in the array, add a cell to the row. If the item is not null, set the cell's class to the item's value
        gridHTML += "</tr>";
      });
      document.getElementById("grid").innerHTML = gridHTML;

      //Show the towers
      document.getElementById("towers").classList.remove("hidden");
      for (let tower in towerTypes) document.getElementById("towers").innerHTML += `<img src="../static/img/towerdefense/${tower}.png" id="${tower}">`;

      this.onclick = null;
    };

    function endGame() {
      clearInterval(animate);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      document.getElementById("grid").classList.add("hidden");
      document.getElementById("towers").classList.add("hidden");
      ctx.fillStyle = "white";
      ctx.font = "128px Segoe UI";
      ctx.textAlign = "center";
      ctx.fillText("Game over", 960, 300);
      ctx.font = "64px Segoe UI";
      ctx.fillStyle = "#80ffff";
      ctx.fillText(`Time: ${Math.floor(seconds / 60)}:${seconds % 60 < 10 ? "0" + seconds % 60 : seconds % 60}`, 960, 500);
      ctx.font = "48px Segoe UI";
      ctx.fillStyle = "white";
      ctx.fillText("Click to play again", 960, 800);
      document.getElementById("game").onclick = () => window.location.reload();
    }
  </script>
{% endblock %}
